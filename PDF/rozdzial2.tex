\chapter{Implementacja}
\thispagestyle{chapterBeginStyle}

Przedmiotem tego rozdziału będzie opis implementacji dwóch podprogramów realizujących: 
\begin{enumerate}
	\item aproksymacyjny algorytm First Fit Decreasing 
	\item sformułowanie liniowe z sekcji \ref{linear_formula}.	
\end{enumerate}

Obydwa zostały zaimplementowane w języku C, w standardzie C17. Motywem tego wyboru były prędkość wykonywania skompilowanego programu, jak i fakt, że API wybranego solver GLPK zostało napisane w C, co pozwala na bezpośrednie jego wywołania z poziomu tego języka\cite{GLPK_API}.
Zrealizowano je w postaci programu konsolowego, który dla odpowiednich flag wywołuje odpowiadające funkcje. Użyto GLPK (GNU Linear Programming Kit) w wersji 5.0.

\section{Dane wejściowe}
Pierwszy punkt z przepływu danych w programie, czyli zczytanie wejścia można zrealizować na dwa sposoby. Pierwszy to ręczne wpisywanie z klawiatury w konsoli danych o które wnoszą komunikaty. Drugi to przygotowanie wcześniej pliku w odpowiednim formacie i podanie jego ścieżki jako argument do programu po fladze \textbf{-f}. Tak prezentuje się format danych dal obydwu przypadków: \\


\begin{table}[!h]
	\begin{center}
		\begin{tabular}{ p{5cm}p{2cm}p{7cm} }
			\multicolumn{3}{l}{$\beta$ (długość belki)} \\
			\multicolumn{3}{l}{$d$ (liczba różnych długości - rodzajów elementów)} \\
			$p_1$ (długość elementu 1) &  \texttt{\char32} & $n_1$ (potrzebna liczba sztuk elementu 1)\\
			$p_2$ &  \texttt{\char32}  & $n_2$ \\
			\vdots & \vdots & \vdots \\
			$p_d$ &  \texttt{\char32} & $n_d$ \\
		\end{tabular}
		\caption{Format danych wejściowych. Każdy wiersz to nowa linia, ``\texttt{\char32}`` oznacza białe znaki }
	\end{center}
\end{table}
Dane wejściowe są zapisywane do struktury \textit{ProblemInstance}, która zawiera w sobie tablicę sturktur typu \textit{ObjWithQuantity}(jej polami przechowują $p_i$, $n_i$). Ta druga sortowana jest według długości obiektów w kolejnośći nierosnącej algorytmem quicksort.
Każde ułożenie elementów na pojedyńczej belce jest reprezentowane przez stukturę typu \textit{StockConfig}. Zawiera ona tablicę, która informuje ile elementów danej długości, zaczynając od najdluższych przy zerowym indeksie, zostało upakowanych do belki. Druga zmienna w tej strukturze odpowiada pozostałej w belce przestrzeni po odjęciu długości zajmowanej przez konfigurację.

\subsection{Przykład}\label{example}
Za przykład posluży tutaj dobrze znany w literaturze zestaw danych o długości belki 5600 z trzynastoma rodzajami elementów \cite{EXAMPLE_REF}.

\begin{lstlisting} 
5600
13
1380 22
1520 25
1560 12
1710 14
1820 18
1880 18
1930 20
2000 10
2050 12
2100 14
2140 16
2150 18
2200 20 
\end{lstlisting}

\section{Algorytm aproksymacyjny}
Główna funkcjonalność ma miejsce w funkcji zdefiniowanej nastepująco: \\ \verb|size_t approx(ProblemInstance *input, Vector *v)| w pliku \textbf{SourceCode/src/approx.c}. \\
Jest to implementacja pseudokodu z sekcji \ref{approx_pseudocode}.
Składają się na nią głównie trzy zagnieżdżone w sobie pętle iteracyjne.
Pierwsza iteruje po rodzajach obiektów ($d$ razy).
Następna wewętrzna iteruje tyle razy ile wynosi liczba potrzebnych elementu danego typu ($n_i$).
Ostatnia, najgłębiej zagnieżdżona, przechodzi po dynamicznie zaalokowanej tablicy (zmienna typu \textit{Vector}) \textit{otwartych} belek, zaczynąjąc od tego do którego ostatniego mieścił się element danego typu. Pozwala to uniknąć niepotrzbnego sprawdzania belek, co do których jest pewność, że dany typ się nie zmieści. 
Po wyjściu z trzeciej pętli następuje sprawdzenie warunku, czy dany obiekt został umieszczony w którejś z otwartych belk. Jeśli tak się nie stało, tworzona i dodawana do dynamicznej tablicy zostaje nowa belka z wpisanym do niej, obecnie rozważanym do włożenia, elementem.

\section{Programowanie liniowe - MIP}
\subsection{Generowanie konfiguracji}
Problemem pośrednim w przypadku implementacji sformułowania liniowego z sekcji \ref{linear_formula} jest sposób generowania możliwych konfiguracji mogących wystąpić na pojedyńczej belce.
Z racji występowania w formułach znaków nierówności, a nie równości, pozwolono sobie na całkowite wypełnianie dostępnej w belkach przestrzeni, co nie wpływa jednak na finalną liczbę potrzebnych belek, a jedynie na pozostałą przestrzeń w każdej z nich, która zostanie podzielona pod nadmiarowe elementy. W optymalnym rozwiązaniu pozostałaby po prostu niepodzielona.\\
Kod znajduje się w pliku: \verb|SourceCode/src/gen_config.c|,  \\ zdefiniowany w funkcji: \\ \verb|static inline int gen_configs_tree(ProblemInstance *input, glp_prob *lp);| \\
Z powodu prostoty i efektywności zaimplementowany został algorytm generujacy konfiguracje leksykograficznie. Patrząc na jego schemat abstrakcyjnie, generuje on $d + 1$ - poziomowe drzewo, ktorego węzły reprezentują pozostałą przestrzeń, krawędzie ile elementów danego typu (poziomu), zaczynając od najdłuższego, mieści się w konfiguracji, która jest czytana jako wartości wezłów na ścieżce od korzenia (długośc belki) do liścia (pozostała finalnie przestrzeń).
Szczegółowy opis tej metody można przeczytać w pracy Saad M.A. Sulimana \textit{Pattern generating procedure for the cutting stock problem} \cite{GEN_CONFIGS}. \\

\subsection{Macierz ograniczeń} \label{macierz_ograniczen}
Do przechowywania wygenerowanych w opisany wyżej sposób danych, wykorzystane zostało wywołanie API solvera GLPK zdefiniowane następująco: \\
\verb|void glp_set_mat_col(glp_prob *P, int j, int len, const int *ind, const double *val)| \\
Z opisu w dokumentacji \cite{GLPK_DOCS} można dowiedzieć się, że:
\begin{itemize}
	\item \textbf{P*} - wskaźnik na obiekt będący instancją problemu
	\item \textbf{len} - $0 \leq len \leq m$, gdzie $m$ to długość $j$-tej kolumny, w naszym przypadku $m = d$
	\item \textbf{ind*} - wskażnik na tablicę indeksów, przykładowo, gdy ind[$i$] = $k$, wtedy val[$i$] będzie w $k$-tym wierszu $\mathbf{j}$-tej kolumny macierzy ograniczeń
	\item \textbf{val*} - wskażnik na tablicę wartośći
\end{itemize}
\textbf{val} i \textbf{ind} powinny mieć rozmiar len+1, ponieważ numeracja indeksów w bibliotece GLPK rozpoczyna się od jedynki, w przeciwieństwie do numeracji w języku C, rozpoczynającej się od zera. \\

Dla przytoczonego powyżej przykładu \ref{example} jedna z konfiguracji mogłaby wyglądać następująco:

\begin{lstlisting}
col.config to tablica: {0, 0, 0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0}            
// col (zmienna typu StockConfig)	
// zmienne przekazywane w wywołaniu bibliotecznym przezentowałyby się tak: 
ind[1] = 7; val[1] = col.config[1-1] // = 1; 
ind[2] = 9; val[2] = col.config[2-1] // = 2; 
\end{lstlisting}


Przy wielu instancjach PCB może okazać się, że finalna macierz ograniczeń ma postać macierzy rzadkiej, czyli takiej w której większość elementów ma wartość zero. Dlatego wartym wpomnienia jest fakt, że nie trzeba obawiać się wpisywania zer w tablicę val, ponieważ macierz ograniczeń w GLPK została zaimplementowana w taki sposób, iż zapamiętuje jedynie niezerowe wartośći, cytując dokumentację: \textit{Zero elements are allowed, but they are not stored in the constraint matrix}. To pozytywnie wpływa na zużycie pamięci operacyjnej jak również na prędkość wywoływanych z macierzą jako argumentem algorytmów. W kodzie źródłowym biblioteki można znaleźć opis implementacji tego mechanizmu \cite{GLPK_SRC}.

\subsection{Nakładanie ograniczeń}
Kolejnym krokiem w uzupełnieniu danych potrzebnych solverowi jest nałożenie ograniczeń na  wiersze i kolumny. W tym przypadku na $d$ wierszy zostały nałożone  ograniczenia dolne, ktore odpowiadają wartościom po prawej stronie znaków nierówności z formuły (wymaganej liczbie elementów danego typu). Kolumnom należało ustawić ograniczenie dolne równe zero.
Dla wierszy odpowiada za to funkcja: \\
\verb|void glp_set_row_bnds(glp_prob *P, int i, int type, double lb, double ub)|
\begin{itemize}
	\item \textbf{P*} - to samo co wcześniej
	\item \textbf{i} - numer wiersza na który nałożone mają zostać ograniczenia
	\item \textbf{type} - typ ograniczenia, nas interesuje wartość numeryczna GLP\_LO, czyli ograniczenie dolne, wtedy dla zmiennej pomocniczej związanej z $i$-tym wierszem wygląda to tak: $\mathbf{lb} \leq x \le +\infty$
	\item \textbf{lb} - wartość ograniczenia dolnego
	\item \textbf{ub} - wartość ograniczenia górnego
\end{itemize}
Analogicznie wygląda to dla kolumn: \\
\verb|void glp set col bnds(glp prob *P, int j, int type, double lb, double ub)|

\subsection{Typ zmiennych}
Również w przypadku MIP można dać znać solverowi od których zmiennych wymagamy, aby były całkowite. W naszym przypadku są to wszystkie, a jest ich tyle ile kolumn (konfiguracji).
Potrzebne jest wywołanie funkcji:
\verb|void glp_set_col_kind(glp_prob *P, int j, int kind)|

\begin{itemize}
	\item \textbf{P*} - to samo co wcześniej
	\item \textbf{j} - numer kolumny której rodzaj ma być zmieniony
	\item \textbf{kind} - rodzaj kolumny, wartość GLP\_IV odpowiada za typ całkowity
\end{itemize}

\subsection{Funkcja celu}
Kierunek optymalizaji (minimalizacja czy maksymalizacja) można ustawić wywołując funkcję: \\
\verb|void glp_set_obj_dir(glp_prob *P, int dir)| \\
\textbf{dir} jest w stanie przyjąć wartości kryjące sie pod stałymi: \\
GLP\_MIN - minimalizacja \\
GLP\_MAX - maksymalizacja \\

Za ustawienie współczynników $j$-tej zmiennej w funkcji celu odpowiada funkcja: \\
\verb|void glp_set_obj_coef(glp_prob *P, int j, double coef)| \\
W tym przypadku wszystkim zmiennym zostają nadane współczynniki równe jeden.

\subsection{Metody rozwiązujące problem}
Teraz pozostaje, tak opisany w programie, problem rozwiązć. GLPK do rozwiązywania problemów MIP używa solvera opartego na metodzie \textit{branch-and-cut}, która jest hybrydą metod \textit{branch-and-bound} i \textit{cutting plane}. 
Metoda ta polega na wstępnej relaksacji ograniczeń całkowitych, znalezieniu rozwiązania pochodnego i takiej jego modyfikacji by spełniała oryginalne sformułowanie (z ograniczeniami całkowitymi).

Wstępne poluzowanie ograniczeń i znalezenie rozwiązania optymalnego dla powstałego problemu pochodnego można osiagnąc poprzez włącznie \textit{presolvera}, który to wywołuje metodę \textit{sympleksową}.
Wywołanie może wyglądać tak:
\begin{lstlisting}[language=C]
	// lp - wskaźnik na zmienną typu glp_prob
	glp_iocp mip_parm;          // zmienna odpowiadająca za parametry MIP
	glp_init_iocp(&mip_parm);   // inicjuje domyślne parametry
	mip_parm.presolve = GLP_ON; // włączenie presolvera
	glp_intopt(lp, &mip_parm);  // wywołanie solvera MIP
\end{lstlisting}


\subsection{Odzyskanie rozwiązania}
Funkcja \verb|int glp_mip_status(glp_prob *P)| informuje o stanie rozwiązania MIP znalezionego przez solver MIP. Gdy zwróci GLP\_OPT - rozwiązanie jest optymalne pod względem liczby całkowitej. \\
Do uzyskania wartości funkcji celu (w tym wypadku liczba potrzenych belek) dla rozwiązania MIP należy wywołać funkcję \\ 
\verb|double glp_mip_obj_val(glp_prob *P)|. \\
Funkcja \verb|double glp_mip_col_val(glp_prob *P, int j)| zwraca wartość zmiennej związanej z $j$-tą kolumną. Interesują nas niezerowe wartości, odpowiadające liczbie potrzebnych konfiguracji o indeksie $j$. Zapisane wcześniej konfiguracje można odzyskać, używając funkcji: \\
\verb|int glp_get_mat_col(glp_prob *P, int j, int ind[], double val[])|, \\
która zwróci dwie tablice, które mają strukturę analogiczną jak w przypadku umieszczania konfiguracji w instancji problemu (patrz \ref{macierz_ograniczen}). 

Z takimi danymi poddanymi odpowiedniemu formowatowaniu, można przejść do etapu drukowania rozwiązania. Tekst wyjścia programu dla przytoczonego wyżej przykładu można zobaczyć na obrazie \ref{output_example}.

\begin{figure}[h!]
	\lstinputlisting{example_result.txt}
	\caption{Przykładowe wydrukowane wyjście dla programu używajacego MIP}
	\label{output_example}
\end{figure}

Każda konfuguracja C[$i$] o indeksie $i$ składa się z $d$ (w tym wypadku trzynastu) kolumn, odpowiadających posortowanym rodzajom obiektów po słowie LENGHT i QUANTITY. Wartość każdej z tych kolumn to liczba elementów danego typu występująca w konfiguracji. 
W przypadku MIP występują dodatkowe, rozpoczynające się znakami: $\%$, x, po których nastepują wartości odpowiedno: pozostałej niewykorzystanej przestrzeni w pojedyńczej belce, liczbie potrzebnych belek z daną konfiguracją.
Gdy w programie wykonywana była metoda APPROX, każda belka jest rozpisywana osobno, w nowym wierszu. Nie pojawia sie kolumna informująca ile razy dana konfiguracja została użyta. 






