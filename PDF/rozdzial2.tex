\chapter{Implementacja}
\thispagestyle{chapterBeginStyle}

Przedmiotem tego rozdziału będzie opis implementacji dwóch podprogramów realizujących: 
\begin{enumerate}
	\item aproksymacyjny algorytm First Fit Decreasing 
	\item sformułowanie liniowe z sekcji 1.2.	
\end{enumerate}

Obydwa zostały zaimplementowane w języku C, w standardzie C17. Motywem tego wyboru były prędkość wykonywania skompilowanego programu, jak i fakt, że API wybranego solver GLPK zostało napisane w C, co pozwala na bezpośrednie jego wywołania z poziomu tego języka\cite{GLPK_API}.
Zrealizowano je w postaci programu konsolowego, który dla odpowiednich flag wywołuje odpowiadające funkcje. 

\section{Dane wejściowe}
Pierwszy punkt z przepływu danych w programie, czyli zczytanie wejścia można zrealizować na dwa sposoby. Pierwszy to ręczne wpisywanie z klawiatury w konsoli danych o które wnoszą komunikaty. Drugi to przygotowanie wcześniej pliku w odpowiednim formacie i podanie jego ścieżki jako argument do programu po fladze \textbf{-f}. Tak prezentuje się format danych dal obydwu przypadków: \\


\begin{table}[!h]
	\begin{center}
		\begin{tabular}{ p{5cm}p{2cm}p{7cm} }
			\multicolumn{3}{l}{$\beta$ (długość belki)} \\
			\multicolumn{3}{l}{$d$ (liczba różnych długości - rodzajów elementów)} \\
			$p_1$ (długość elementu 1) & space & $n_1$ (potrzebna liczba sztuk elementu 1)\\
			$p_2$ & space & $n_2$ \\
			\vdots & \vdots & \vdots \\
			$p_d$ & space & $n_d$ \\
		\end{tabular}
		\caption{Format danych wejściowych. Każdy wiersz to nowa linia. Space oznacza spację.}
	\end{center}
\end{table}
Dane wejściowe są zapisywane do struktury \textit{ProblemInstance}, która zawiera w sobie tablicę sturktur typu \textit{ObjWithQuantity}(jej polami przechowują $p_i$, $n_i$). Ta druga sortowana jest według długości obiektów w kolejnośći nierosnącej algorytmem quicksort.
Każde ułożenie elementów na pojedyńczej belce jest reprezentowane przez stukturę typu \textit{StockConfig}. Zawiera ona tablicę, która informuje ile elementów danej długości, zaczynając od najdluższych przy zerowym indeksie, zostało upakowanych do belki. Druga zmienna w tej strukturze odpowiada pozostałej w belce przestrzeni po odjęciu długości zajmowanej przez konfigurację.


\section{Algorytm aproksymacyjny}
Główna funkcjonalność ma miejsce w funkcji zdefiniowanej nastepująco: \\ \verb|size_t approx(ProblemInstance *input, Vector *v)| w pliku \textbf{SourceCode/src/approx.c}. \\
Jest to implementacja pseudokodu z sekcji \ref{approx_pseudocode}.
Składają się na nią głównie trzy zagnieżdżone w sobie pętle iteracyjne.
Pierwsza iteruje po rodzajach obiektów ($d$ razy).
Następna wewętrzna iteruje tyle razy ile wynosi liczba potrzebnych elementu danego typu ($n_i$).
Ostatnia, najgłębiej zagnieżdżona, przechodzi po dynamicznie zaalokowanej tablicy (zmienna typu \textit{Vector}) \textit{otwartych} belek, zaczynąjąc od tego do którego ostatniego mieścił się element danego typu. Pozwala to uniknąć niepotrzbnego sprawdzania belek, co do których jest pewność, że dany typ się nie zmieści. 
Po wyjściu z trzeciej pętli następuje sprawdzenie warunku, czy dany obiekt został umieszczony w którejś z otwartych belk. Jeśli tak się nie stało, tworzona i dodawana do dynamicznej tablicy zostaje nowa belka z wpisanym do niej, obecnie rozważanym do włożenia, elementem.

\section{Programowanie liniowe - MIP}
\subsection{Generowanie konfiguracji}
Problemem pośrednim w przypadku implementacji sformułowania liniowego z sekcji \ref{linear_formula} jest sposób generowania możliwych konfiguracji mogących wystąpić na pojedyńczej belce.
Z racji występowania w formułach znaków nierówności, a nie równości, pozwolono sobie na całkowite wypełnianie dostępnej w belkach przestrzeni, co nie wpływa jednak na finalną liczbę potrzebnych belek, a jedynie na pozostałą przestrzeń w każdej z nich, która zostanie podzielona pod nadmiarowe elementy. W optymalnym rozwiązaniu pozostałaby po prostu niepodzielona.\\
Kod znajduje się w pliku: \verb|SourceCode/src/gen_config.c|,  \\ zdefiniowany w funkcji: \\ \verb|static inline int gen_configs_tree(ProblemInstance *input, glp_prob *lp);| \\
\textbf{Ten fragment ma chyba za długie zdanie złożone??? Pytanie też czy dawać te wstawki, gdzie jest kod.}
Z powodu prostoty i efektywności zaimplementowany został algorytm generujacy konfiguracje leksykograficznie. Patrząc na jego schemat abstrakcyjnie, generuje on $d + 1$ - poziomowe drzewo, ktorego węzły reprezentują pozostałą przestrzeń, krawędzie ile elementów danego typu (poziomu), zaczynając od najdłuższego, mieści się w konfiguracji, która jest czytana jako wartości wezłów na ścieżce od korzenia (długośc belki) do liścia (pozostała finalnie przestrzeń).
Szczegółowy opis tej metody można przeczytać w pracy Saad M.A. Sulimana \textit{Pattern generating procedure for the cutting stock problem} \cite{GEN_CONFIGS}. \\
\subsection{Macierz ograniczeń}
Do przechowywania wygenerowanych w opisany wyżej sposób danych, wykorzystane zostało wywołanie API solvera GLPK zdefiniowane następująco: \\
\verb|void glp_set_mat_col(glp_prob *P, int j, int len, const int *ind, const double *val)| \\
Z opisu w dokumentacji \cite{GLPK_DOCS} można dowiedzieć się, że:
\begin{itemize}
	\item \textbf{P*} - wskaźnik na obiekt będący instancją problemu
	\item \textbf{len} - $0 \leq len \leq m$, gdzie $m$ to długość $j$-tej kolumny, w naszym przypadku $m = d$
	\item \textbf{ind*} - wskażnik na tablicę indeksów, przykładowo, gdy ind[$i$] = $k$, wtedy val[$i$] będzie w $k$-tym wierszu $j$-tej kolumny macierzy ograniczeń
	\item \textbf{val*} - wskażnik na tablicę wartośći
\end{itemize}
\textbf{val} i \textbf{ind} powinny mieć rozmiar len+1, ponieważ numeracja indeksów w bibliotece GLPK rozpoczyna się od jedynki, w przeciwieństwie do numeracji w języku C, rozpoczynającej się od zera. \\

Dla przykładu, poniżej wartości zmiennych dla pewnej kofiguracji przy $d=5$. \\
Gdyby pole \textit{config} zmiennej StockConfig wyglądało następująco: \{2, 3, 0, 0, 5\}, wtedy zmienne przekazywane w wywołaniu bibliotecznym przezentowałyby się tak: \\
ind[1] = 1; val[1] = col.config[0]; \\
ind[2] = 2; val[2] = col.config[1]; \\
ind[5] = 5; val[3] = col.config[4]; \\

Przy wielu instancjach PCB może okazać się, że finalna macierz ograniczeń ma postać macierzy rzadkiej, czyli takiej w której większość elementów ma wartość zero. Dlatego wartym wpomnienia jest fakt, że nie trzeba obawiać się wpisywania zer w tablicę val, ponieważ macierz ograniczeń w GLPK została zaimplementowana w taki sposób, iż zapamiętuje jedynie niezerowe wartośći, cytując dokumentację: \textit{Zero elements are allowed, but they are not stored in the constraint matrix}. To pozytywnie wpływa na zużycie pamięci operacyjnej jak również na prędkość wywoływanych z macierzą jako argumentem algorytmów. W kodzie źródłowym biblioteki można znaleźć opis implementacji tego mechanizmu \cite{GLPK_SRC}.



